# [기획/설계] 틈새 찾기

**"코딩 시작 전에 버그 절반은 잡을 수 있습니다."**

---

## 문서 검토의 중요성

정적 테스트는 실행 없이 문서나 코드를 검토하여 결함을 찾는 방법입니다. 구현 전 단계에서 결함을 발견하면 수정 비용이 10배 이상 절감됩니다.

### 검토 효과
- **요구사항 단계 발견**: 수정 비용 1배
- **설계 단계 발견**: 수정 비용 5배
- **구현 단계 발견**: 수정 비용 10배
- **테스트 단계 발견**: 수정 비용 20배
- **운영 단계 발견**: 수정 비용 100배

---

## 요구사항 명세서 검토 체크리스트

### 명확성 검증
- [ ] 모호한 단어 사용 여부 (약간, 적절히, 보통 등)
- [ ] "할 수 있다" vs "해야 한다" 구분 명확
- [ ] 수치화 가능한 기준 제시 (응답시간 3초 이내 등)
- [ ] 주어, 목적어 명확히 명시

**나쁜 예시:**
> "시스템은 빠르게 응답해야 한다"

**좋은 예시:**
> "사용자 로그인 요청 시 시스템은 3초 이내에 응답해야 한다"

### 완전성 검증
- [ ] 모든 사용자 시나리오 포함
- [ ] 예외 상황 처리 방법 정의
- [ ] 비기능 요구사항 포함 (성능, 보안, 가용성)
- [ ] 인터페이스 요구사항 명시

### 일관성 검증
- [ ] 용어 사전 일관성 (로그인 ↔ 인증 혼용 금지)
- [ ] 요구사항 간 모순 없음
- [ ] 우선순위 일관성

### 테스트 가능성 검증
- [ ] 측정 가능한 기준 제시
- [ ] 검증 방법 정의 가능
- [ ] 테스트 데이터 획득 가능

---

## 설계서 검토 포인트

### 아키텍처 검토
| 검토 항목 | 확인 질문 | 위험도 |
|---------|---------|--------|
| 확장성 | 사용자 증가 시 대응 가능한가? | 높음 |
| 가용성 | 단일 장애점(SPOF)이 있는가? | 높음 |
| 보안 | 민감 데이터 암호화 방안은? | 높음 |
| 성능 | 병목 지점은 어디인가? | 중간 |

### API 설계 검토
```
✓ 체크 포인트:
- 요청/응답 형식 명확히 정의
- 에러 코드 체계 정의
- 버전 관리 전략
- 인증/인가 방식
- Rate Limiting 정책
```

### 데이터베이스 설계 검토
- [ ] 정규화 적절성
- [ ] 인덱스 전략
- [ ] 백업/복구 계획
- [ ] 마이그레이션 계획

---

## 코드 리뷰 실전 가이드

### 보안 취약점 체크리스트
```javascript
// 나쁜 예: SQL Injection 취약
const query = `SELECT * FROM users WHERE id = ${userId}`;

// 좋은 예: Prepared Statement
const query = 'SELECT * FROM users WHERE id = ?';
db.execute(query, [userId]);
```

- [ ] 사용자 입력값 검증 및 필터링
- [ ] SQL Injection 방지 (Prepared Statement)
- [ ] XSS 방지 (입력값 이스케이프)
- [ ] 민감정보 하드코딩 금지
- [ ] 인증/인가 적절히 구현

### 성능 이슈 체크리스트
- [ ] N+1 쿼리 문제
- [ ] 불필요한 반복문 중첩
- [ ] 메모리 누수 가능성
- [ ] 캐싱 활용 여부

### 가독성 체크리스트
- [ ] 함수는 한 가지 역할만
- [ ] 매직 넘버 대신 상수 사용
- [ ] 의미 있는 변수명
- [ ] 적절한 주석 (why, not what)

---

## 실무 팁

### 1. 기획 단계부터 참여
**효과**: 테스트 효율성 30% 향상, 결함 예방률 50% 증가

**실천 방법:**
- 요구사항 정의 회의 참석
- "테스트 가능성" 관점에서 피드백
- 애매한 표현 즉시 질문

### 2. 체크리스트 활용
```
[ ] 요구사항 ID가 모두 고유한가?
[ ] 우선순위가 명시되어 있는가?
[ ] 모든 요구사항에 출처가 있는가?
[ ] 비기능 요구사항이 포함되었는가?
[ ] 수용 기준이 명확한가?
```

### 3. 정적 분석 도구 활용

| 도구 | 언어 | 주요 기능 |
|-----|------|----------|
| SonarQube | 다중 언어 | 코드 품질, 보안 취약점 |
| ESLint | JavaScript | 코딩 컨벤션, 잠재적 오류 |
| Checkstyle | Java | 코딩 표준 준수 |
| Pylint | Python | 코드 품질, PEP8 준수 |

**CI/CD 통합 예시:**
```yaml
# .github/workflows/code-quality.yml
- name: SonarQube Scan
  run: sonar-scanner
- name: ESLint Check
  run: npm run lint
```

---

## 실전 사례

### 사례 1: 요구사항 검토로 3건 결함 예방

**상황**: 금융 앱 '계좌 이체' 기능 개발

**발견한 문제:**
1. "금액 0원 이체 허용 여부" 미정의
2. "1일 이체 한도" 명시 없음
3. "공휴일 이체 처리" 방법 불명확

**조치**: 기획자와 협의하여 명확히 정의

**결과**: 구현 후 발견 시 예상 수정 시간 3일 → 사전 예방으로 0.5일 소요

### 사례 2: 코드 리뷰로 보안 취약점 발견

**발견 내용:**
```python
# 위험: 비밀번호 평문 로깅
logger.info(f"User login: {username}, password: {password}")
```

**개선:**
```python
# 안전: 민감 정보 마스킹
logger.info(f"User login: {username}, password: ****")
```

**영향**: 운영 환경 로그 노출 시 보안 사고 예방

### 사례 3: 설계 검토로 성능 개선

**문제**: API 설계서에서 "모든 사용자 정보 조회 후 필터링" 방식 발견

**제안**: 데이터베이스에서 필터링 후 조회

**효과**: 응답 시간 5초 → 0.5초로 단축 (10배 개선)

---

## 실무 워크숍: 요구사항 검토 실습

### 연습 문제
다음 요구사항의 문제점을 찾아보세요:

> "회원 가입 시 비밀번호는 적절히 복잡해야 하며, 시스템은 빠르게 처리해야 한다.
> 이메일 인증은 필요에 따라 수행할 수 있다."

<details>
<summary>해답 보기</summary>

**문제점:**
1. "적절히 복잡" → 구체적 기준 없음 (예: 8자 이상, 영문+숫자+특수문자)
2. "빠르게 처리" → 정량적 기준 없음 (예: 3초 이내)
3. "필요에 따라" → 조건 불명확 (예: 모든 신규 회원 필수)
4. "수행할 수 있다" → 필수/선택 불명확

**개선안:**
> "회원 가입 시 비밀번호는 8자 이상, 영문 대소문자, 숫자, 특수문자를 각 1개 이상 포함해야 한다.
> 시스템은 회원 가입 요청을 3초 이내에 처리해야 한다.
> 모든 신규 회원은 이메일 인증을 완료해야 로그인이 가능하다."
</details>
