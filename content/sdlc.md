# 소프트웨어 수명 주기와 테스트 (Testing Throughout the SDLC)

## 개발 모델과 테스트

### V-모델

V-모델은 소프트웨어 개발과 테스트가 서로 대칭적인 관계를 이루는 모델입니다. 각 개발 단계에 대응하는 테스트 단계가 존재합니다.

#### V-모델의 단계:

1. **요구사항 분석** → **수용 테스트 (Acceptance Testing)**
   - 사용자 요구사항을 검증
   - 시스템이 사용자 기대를 충족하는지 확인

2. **시스템 설계** → **시스템 테스트 (System Testing)**
   - 전체 시스템 기능 검증
   - 비기능 요구사항 검증

3. **아키텍처 설계** → **통합 테스트 (Integration Testing)**
   - 구성 요소 간 상호작용 검증
   - 인터페이스 테스트

4. **모듈 설계** → **단위 테스트 (Unit Testing)**
   - 개별 구성 요소 기능 검증
   - 개발자 중심의 테스트

#### V-모델의 장점:
- 조기 결함 발견
- 명확한 테스트 목표
- 문서 중심의 체계적 접근

#### V-모델의 단점:
- 유연성 부족
- 고객 피드백 반영 어려움
- 후반 단계에서 문제 발생 시 수정 비용 증가

### 애자일 모델 내의 테스트

애자일 개발에서는 테스트가 반복적이고 지속적인 방식으로 수행됩니다.

#### 애자일 테스트의 특징:
- **지속적인 테스트**: 각 스프린트마다 테스트 수행
- **테스트 주도 개발 (TDD)**: 테스트 케이스 작성 후 개발
- **통합 테스트 자동화**: 빌드와 함께 자동 실행
- **콜라보레이션 강조**: 테스터, 개발자, PO 간 협업

#### 애자일 테스트 피라미드:
1. **단위 테스트 (Unit Tests)** - 70%
2. **통합 테스트 (Integration Tests)** - 20%
3. **UI/엔드 투 엔드 테스트 (UI/E2E Tests)** - 10%

## 테스트 레벨

### 단위 테스트 (Unit Testing)

- **정의**: 개별 구성 요소나 함수 수준에서의 테스트
- **수행자**: 개발자
- **목표**: 코드 로직 검증
- **도구**: JUnit, NUnit, PyTest 등
- **장점**: 빠른 실행, 정확한 결함 위치 파악

### 통합 테스트 (Integration Testing)

- **정의**: 여러 구성 요소 간 상호작용 테스트
- **수행자**: 개발자 또는 테스터
- **목표**: 인터페이스 및 통합 기능 검증
- **전략**:
  - Big Bang 통합
  - Top-Down 통합
  - Bottom-Up 통합
  - Sandwich 통합

### 시스템 테스트 (System Testing)

- **정의**: 전체 시스템의 기능 및 비기능 테스트
- **수행자**: 독립 테스트 팀
- **목표**: 시스템 요구사항 충족 확인
- **범주**:
  - 기능 테스트
  - 성능 테스트
  - 보안 테스트
  - 호환성 테스트

### 인수 테스트 (Acceptance Testing)

- **정의**: 사용자 또는 고객이 시스템 수용 여부 판단
- **수행자**: 최종 사용자 또는 고객
- **목표**: 비즈니스 요구사항 충족 확인
- **유형**:
  - UAT (User Acceptance Testing)
  - FAT (Factory Acceptance Testing)
  - SAT (Site Acceptance Testing)

## 테스트 유형

### 기능 테스트 (Functional Testing)

- **정의**: 소프트웨어가 요구사항에 따라 기능하는지 검증
- **예시**:
  - 로그인 기능
  - 데이터 검증
  - 계산 로직
  - API 호출

### 비기능 테스트 (Non-Functional Testing)

#### 성능 테스트
- **로드 테스트**: 정상적인 사용자 수에서 시스템 성능
- **스트레스 테스트**: 최대 용량 이상의 부하
- **볼륨 테스트**: 대량 데이터 처리 능력
- **스테이빌리티 테스트**: 장시간 운영 시 안정성

#### 보안 테스트
- **침투 테스트**: 시스템 취약점 평가
- **권한 테스트**: 접근 제어 검증
- **데이터 보호 테스트**: 개인정보 보호 여부

#### 사용성 테스트
- **사용자 친화성**: 인터페이스의 직관성
- **학습 용이성**: 사용자 교육 필요성
- **오류 처리**: 사용자 오류에 대한 시스템 반응

### 화이트박스 테스트 vs 블랙박스 테스트

#### 화이트박스 테스트 (White Box Testing)
- **정의**: 내부 구조와 로직을 기반으로 테스트
- **기준**:
  - 문장 커버리지 (Statement Coverage)
  - 분기 커버리지 (Branch Coverage)
  - 조건 커버리지 (Condition Coverage)
  - MC/DC 커버리지 (Modified Condition/Decision Coverage)

#### 블랙박스 테스트 (Black Box Testing)
- **정의**: 내부 구조를 알지 못한 채 입력과 출력만 검증
- **기법**:
  - 동등 분할
  - 경계값 분석
  - 결정 테이블
  - 상태 전이

### 확인 테스트와 회귀 테스트

#### 확인 테스트 (Confirmation Testing)
- **정의**: 결함 수정 후 해당 결함이 해결되었는지 확인
- **목표**: 결함이 실제로 수정되었는지 검증

#### 회귀 테스트 (Regression Testing)
- **정의**: 새로운 코드 변경이 기존 기능에 영향을 주지 않는지 확인
- **필요성**: 코드 변경으로 인한 부작용 방지
- **자동화**: 반복적 실행을 위한 자동화 필수

## 테스트 레벨과 테스트 유형의 관계

| 테스트 레벨 | 기능 테스트 | 비기능 테스트 | 화이트박스 테스트 | 블랙박스 테스트 |
|-------------|-------------|---------------|-------------------|-----------------|
| 단위 테스트 | 부분적 | 없음 | 주로 | 부분적 |
| 통합 테스트 | 부분적 | 부분적 | 부분적 | 주로 |
| 시스템 테스트 | 주로 | 주로 | 부분적 | 주로 |
| 인수 테스트 | 주로 | 주로 | 없음 | 주로 |

이와 같은 구조를 통해 테스트는 전체 소프트웨어 개발 생명 주기를 통해 체계적으로 수행되어야 하며, 각 단계에서 적절한 테스트 유형을 적용함으로써 소프트웨어 품질을 극대화할 수 있습니다.